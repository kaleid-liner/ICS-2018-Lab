# LAB0-Report

- 姓名：魏剑宇
- 学号：PB17111586

---

## 最终代码

|machine|assembly|
| :---:|:---:|
|0011000000000000|.ORIG x3000|
|0101100000100000|ADD R4,R0,#0|
|0001001100100010|ADD R1,R4,#2|
|0001010100100001|ADD R2,R4,#1|
|0101011001000000|AND R3,R1,R0|
|0000010000000001|BRz #1|
|0001100100000010|ADD R4,R4,R2|
|0001010010000010|ADD R2,R2,R2|
|0001001001000001|ADD R1,R1,R1|
|0000101111111010|BRnp #-6|
|0001000100000011|ADD R0,R4,R3|
|1111000000100101|HALT|

## 实验过程

### 算法的思考过程

- 首先，考虑`SAR`的实现方法，有两个思路：
  1. 通过除法$\div 2$。由于没有除法指令，通过二分法实现的复杂度为$O(\lg n)$=bits of n，效率与第二种相同，但实现起来较复杂，指令较多。
  2. **通过位操作**。
- 由于LC-3的位操作指令只有AND，故考虑从AND入手。
- **左移**：左移操作很好实现，只需将其$\times 2$，即加上它自己。
- **最高位**：最高位需填充符号位，可能需要特殊处理。

### 最终算法

从次低位开始扫描R0中的数，若该位为1，最终结果的低一位置为1，否则置为0。最高位置为原来的次高位。

算法中R4持有原来的R0，R1持有R4的mask，R2持有最终结果（R0）的mask。R3持中间结果。

#### 代码描述

```c
R1 = 2;
R2 = 1;
R4 = R0;
R0 = 0;
R5 = 15; //index
while R5 != 0: //Otherwise, all of the 16 bits have been scanned
	if (R3 = R1 & R4) != 0:
		R0 = R0 + R2;
	R1 = R1 << 1;
	R2 = R2 << 1;
	R5--;
R0 = R0 + R3;
```

#### 优化1

经过仔细观察，发现index是不需要的。可以使用R1判定循环的结束：即**0x80 << 1 = 0**。只需判定R1是否为0。当R1为0，说明循环结束。这样，使用的寄存器从6变为5，指令数从17变为15（皆不计.ORIG 0x3000)。

#### 优化2

由于LC-3没有mov或lea(指接受立即数的lea)，故最早在实现赋值时我这样操作

 ```
R1 <- R1 and 0;
R1 <- R1 add 2;
R2 <- R2 and 0;
R2 <- R2 add 1;
R4 <- R4 and 0;
R4 <- R4 add R0;
R0 <- 0;
 ```

后来发现上面的做法很**愚蠢**。 通过重用R0的值，通过3行代码即可实现

```
R4 <- R0 add 0;
R0 <- 0;
R1 <- R0 add 2;
R2 <- R0 add 1;
```

这样，指令数从15变为12.

#### 优化3
开始使用R4暂存R0的值，使用R0参与运算储存最终结果，发现这样会多一步拷贝操作。即将R0的值拷贝至R4。通过使用R0的值参与运算，使用R4保存最终结果，能少一步拷贝，指令数-1，从12变为11.

### 如何写代码

- ~~`as program.asm -o program.obj; mv program.obj program.bin`~~
- vim编辑hex机器码，`:%!xxd -rp`。
- ~~在txt文件中以0/1字符书写代码后，`mv program.txt program.bin`~~

### 测试

Simulator带有部分Debugger的功能。开始程序前修改R0的值，并与正确答案对照。测试用例的选取大致如下

- 首先，必须考虑正负两种情况下表现是否正确，即符号位为0/1的情况。
- 对符号位为0/1的情况随机取值，测试结果是否正确即可。
- 开始时对R7赋值，结束后观察R7是否改变。
- 例如0x7111（最高位为0），0x8001（最高位为1）。